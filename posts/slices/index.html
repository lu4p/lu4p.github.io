<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Inner workings of allocating slices with go (golang) | lu4p's blog</title><meta name=keywords content><meta name=description content="I wasn&rsquo;t sure what the performance impact of preallocating a slice with make vs. just letting the slice grow via append is, so I investigated a little.
Arrays In order to understand what a slice is one needs to first understand how arrays work in go.
An array&rsquo;s type definition specifies a length and an element type. For example, the type [3]int represents an array of three integers.
An array&rsquo;s size is fixed, its length is part of the type, so [2]int and [3]int are incompatible, e."><meta name=author content="lu4p"><link rel=canonical href=https://blog.lu4p.xyz/posts/slices/><link href=https://blog.lu4p.xyz/assets/css/stylesheet.min.57da1366bfd884dc6005936744c35f3a73b7ae47a47b1c3d256a80157ab8a137.css integrity="sha256-V9oTZr/YhNxgBZNnRMNfOnO3rkekexw9JWqAFXq4oTc=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.lu4p.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.lu4p.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.lu4p.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.lu4p.xyz/apple-touch-icon.png><link rel=mask-icon href=https://blog.lu4p.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><meta property="og:title" content="Inner workings of allocating slices with go (golang)"><meta property="og:description" content="I wasn&rsquo;t sure what the performance impact of preallocating a slice with make vs. just letting the slice grow via append is, so I investigated a little.
Arrays In order to understand what a slice is one needs to first understand how arrays work in go.
An array&rsquo;s type definition specifies a length and an element type. For example, the type [3]int represents an array of three integers.
An array&rsquo;s size is fixed, its length is part of the type, so [2]int and [3]int are incompatible, e."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.lu4p.xyz/posts/slices/"><meta property="article:published_time" content="2020-12-02T22:23:20+01:00"><meta property="article:modified_time" content="2020-12-02T22:23:20+01:00"><meta property="og:site_name" content="lu4p"><meta name=twitter:card content="summary"><meta name=twitter:title content="Inner workings of allocating slices with go (golang)"><meta name=twitter:description content="I wasn&rsquo;t sure what the performance impact of preallocating a slice with make vs. just letting the slice grow via append is, so I investigated a little.
Arrays In order to understand what a slice is one needs to first understand how arrays work in go.
An array&rsquo;s type definition specifies a length and an element type. For example, the type [3]int represents an array of three integers.
An array&rsquo;s size is fixed, its length is part of the type, so [2]int and [3]int are incompatible, e."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Inner workings of allocating slices with go (golang)","name":"Inner workings of allocating slices with go (golang)","description":"I wasn\u0026amp;rsquo;t sure what the performance impact of preallocating a slice with make vs. just letting the slice grow via append is, so I investigated a little.\nArrays In order to …","keywords":[],"articleBody":"I wasn’t sure what the performance impact of preallocating a slice with make vs. just letting the slice grow via append is, so I investigated a little.\nArrays In order to understand what a slice is one needs to first understand how arrays work in go.\nAn array’s type definition specifies a length and an element type. For example, the type [3]int represents an array of three integers.\nAn array’s size is fixed, its length is part of the type, so [2]int and [3]int are incompatible, e.g. a variable of type [2]int cannot be assigned to a variable of type [3]int.\na := [2]int{1, 2} var b [3]int b = a // Output: cannot use a (type [2]int) as type [3]int in assignment Arrays are initialized right away, the zero value of an array is an array whose elements have their zero value.\nvar b [2]int fmt.Println(b[1]) // Output: 0 In-memory a variable of type [3]int is just 3 integers laid out sequentially.\nAn array is a value, an [3]int variable are just 3 integers, being passed around.\nSlices First of all what is a slice exactly, a slice can be thought of a struct with the following values:\ntype slice struct { len int // the length of the slice \tcap int // the capacity of the slice i.e. the max possible len without allocating new memory \tptr unsafe.Pointer // pointer to the first Element of the underlying array } append append needs to allocate a new underlying array, if the elements to append exceed the capacity of the underlying array, in this case a new bigger array is allocated, all elements copied from the old to the new array, and the new elements are copied after the last element of the copied slice.\n cap is set to the length of the newly allocated array, len is to the index of the last element added via append (+ 1) ptr is set to point to the underlying array  For performance it’s important how often the values are copied around in memory.\nThis is what I came up with, to determine how often the slice is reallocated and copied, I also print some useful information about the allocated capacity of the slice.\npackage main import ( \"fmt\" ) func main() { elmCount := 100_000 fmt.Printf(\"%8v | %8v | %8v | %v\\n\", \"len\", \"prev cap\", \"new cap\", \"ratio added cap\") var foo []int for i := 0; i elmCount; i++ { if i == 0 { foo = append(foo, i) continue } first := \u0026foo[0] beforeCap := cap(foo) foo = append(foo, i) firstNew := \u0026foo[0] // if the start of the underlying array changed \tif firstNew != first { afterCap, afterLen := cap(foo), len(foo) capRatio := float64(afterCap) / float64(beforeCap) fmt.Printf(\"%8v | %8v | %8v | %.2fx\\n\", afterLen, beforeCap, afterCap, capRatio) } } } In the above code a slice of integers with 100 000 elements is created, by using only append.\nThe above code outputs:\n len | prev cap | new cap | ratio added cap 2 | 1 | 2 | 2.00x 3 | 2 | 4 | 2.00x 5 | 4 | 8 | 2.00x 9 | 8 | 16 | 2.00x 17 | 16 | 32 | 2.00x 33 | 32 | 64 | 2.00x 65 | 64 | 128 | 2.00x 129 | 128 | 256 | 2.00x 257 | 256 | 512 | 2.00x 513 | 512 | 1024 | 2.00x 1025 | 1024 | 1280 | 1.25x 1281 | 1280 | 1696 | 1.32x 1697 | 1696 | 2304 | 1.36x 2305 | 2304 | 3072 | 1.33x 3073 | 3072 | 4096 | 1.33x 4097 | 4096 | 5120 | 1.25x 5121 | 5120 | 7168 | 1.40x 7169 | 7168 | 9216 | 1.29x 9217 | 9216 | 12288 | 1.33x 12289 | 12288 | 15360 | 1.25x 15361 | 15360 | 19456 | 1.27x 19457 | 19456 | 24576 | 1.26x 24577 | 24576 | 30720 | 1.25x 30721 | 30720 | 38912 | 1.27x 38913 | 38912 | 49152 | 1.26x 49153 | 49152 | 61440 | 1.25x 61441 | 61440 | 76800 | 1.25x 76801 | 76800 | 96256 | 1.25x 96257 | 96256 | 120832 | 1.26x Interesting it looks like append is smart and doesn’t only grow the slice to the currently needed capacity, but doubles the capacity for smaller capacities (under 1024) and grows it by ~1.25x for larger capacities (over 1024), to reduce the overhead of reallocating arrays.\nIn the runtime this is implemented as follows (full implementation):\nfunc growslice(et *_type, old slice, cap int) slice { ... newcap := old.cap doublecap := newcap + newcap if cap  doublecap { newcap = cap } else { if old.len 1024 { newcap = doublecap } else { // Check 0  // and prevent an infinite loop.  for 0 newcap \u0026\u0026 newcap cap { newcap += newcap / 4 } // Set newcap to the requested cap when  // the newcap calculation overflowed.  if newcap  0 { newcap = cap } } } ... } Performance I benchmarked what the performance impact of preallocating a slice with make vs auto growing via append is, the benchmark populates a slice with N integers them via a for loop.\nfunc plainAppend(elms int) { var foo []int for i := 0; i elms; i++ { foo = append(foo, i) } } func withMake(elms int) { foo := make([]int, 0, elms) for i := 0; i elms; i++ { foo = append(foo, i) } } Full Benchmark: https://gist.github.com/lu4p/4906f5d1b88f23a1f740bb8895f25e40\n$ go test -bench=. -count=10 -benchtime=100x  bench.out # https://godoc.org/golang.org/x/perf/cmd/benchstat $ benchstat bench.out name time/op 10/append-8 729ns ±62% 10/with_make-8 119ns ±84% 100/append-8 1.46µs ±84% 100/with_make-8 454ns ±99% 1k/append-8 5.28µs ±33% 1k/with_make-8 2.61µs ±54% 10k/append-8 111µs ±23% 10k/with_make-8 31.4µs ±11% 100k/append-8 1.16ms ± 8% 100k/with_make-8 248µs ±11% 1Million/append-8 8.57ms ± 3% 1Million/with_make-8 2.83ms ± 1% So in a simple use case preallocating the slice with make seems to be about 2-4 times faster. Although this is significant, in real-world scenarios it often doesn’t really matter because appending is fast enough regardless.\nIf you don’t know the number of elements a to which a slice will grow, it often makes little sense to allocate memory with make beforehand. Of course there are exceptions from this, sometimes you know at least the order of magnitude to which a slice will grow, then it can make sense to allocate a slice with a cap similar to the ballpark of expected elements.\nThanks to Hu1buerger, for helping with the investigation.\n","wordCount":"1104","inLanguage":"en","datePublished":"2020-12-02T22:23:20+01:00","dateModified":"2020-12-02T22:23:20+01:00","author":{"@type":"Person","name":"lu4p"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.lu4p.xyz/posts/slices/"},"publisher":{"@type":"Organization","name":"lu4p's blog","logo":{"@type":"ImageObject","url":"https://blog.lu4p.xyz/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://blog.lu4p.xyz accesskey=h title="lu4p (Alt + H)">lu4p</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Inner workings of allocating slices with go (golang)</h1><div class=post-meta>December 2, 2020&nbsp;·&nbsp;6 min&nbsp;·&nbsp;lu4p</div></header><div class=post-content><p>I wasn&rsquo;t sure what the performance impact of preallocating a slice with <code>make</code> vs.
just letting the slice grow via <code>append</code> is, so I investigated a little.</p><h2 id=arrays>Arrays<a hidden class=anchor aria-hidden=true href=#arrays>#</a></h2><p>In order to understand what a slice is one needs to first understand how arrays work in go.</p><p>An array&rsquo;s type definition specifies a length and an element type.
For example, the type <code>[3]int</code> represents an array of three integers.</p><p>An array&rsquo;s size is fixed, its length is part of the type, so <code>[2]int</code> and <code>[3]int</code> are incompatible,
e.g. a variable of type <code>[2]int</code> cannot be assigned to a variable of type <code>[3]int</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>2</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>
<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>a</span>
<span style=color:#75715e>// Output: cannot use a (type [2]int) as type [3]int in assignment
</span></code></pre></div><p>Arrays are initialized right away, the zero value of an array is an array whose elements have their zero value.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> [<span style=color:#ae81ff>2</span>]<span style=color:#66d9ef>int</span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>b</span>[<span style=color:#ae81ff>1</span>])
<span style=color:#75715e>// Output: 0
</span></code></pre></div><p>In-memory a variable of type <code>[3]int</code> is just 3 integers laid out sequentially.</p><p>An array is a value, an <code>[3]int</code> variable are just 3 integers, being passed around.</p><h2 id=slices>Slices<a hidden class=anchor aria-hidden=true href=#slices>#</a></h2><p>First of all what is a slice exactly, a slice can be thought of a struct with the following values:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>slice</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>len</span> <span style=color:#66d9ef>int</span>            <span style=color:#75715e>// the length of the slice
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>cap</span> <span style=color:#66d9ef>int</span>            <span style=color:#75715e>// the capacity of the slice i.e. the max possible len without allocating new memory
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ptr</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// pointer to the first Element of the underlying array
</span><span style=color:#75715e></span>}
</code></pre></div><h3 id=append>append<a hidden class=anchor aria-hidden=true href=#append>#</a></h3><p><code>append</code> needs to allocate a new underlying array, if the elements to append exceed the capacity of the underlying array,
in this case a new bigger array is allocated, all elements copied from the old to the new array,
and the new elements are copied after the last element of the copied slice.</p><ul><li><code>cap</code> is set to the length of the newly allocated array,</li><li><code>len</code> is to the index of the last element added via <code>append</code> (+ 1)</li><li><code>ptr</code> is set to point to the underlying array</li></ul><p>For performance it&rsquo;s important how often the values are copied around in memory.</p><p>This is what I came up with, to determine how often the slice is reallocated and copied,
I also print some useful information about the allocated capacity of the slice.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>elmCount</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>100</span><span style=color:#a6e22e>_000</span>

	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%8v | %8v | %8v | %v\n&#34;</span>, <span style=color:#e6db74>&#34;len&#34;</span>, <span style=color:#e6db74>&#34;prev cap&#34;</span>, <span style=color:#e6db74>&#34;new cap&#34;</span>, <span style=color:#e6db74>&#34;ratio added cap&#34;</span>)

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>foo</span> []<span style=color:#66d9ef>int</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>elmCount</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>foo</span> = append(<span style=color:#a6e22e>foo</span>, <span style=color:#a6e22e>i</span>)
			<span style=color:#66d9ef>continue</span>
		}

		<span style=color:#a6e22e>first</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>foo</span>[<span style=color:#ae81ff>0</span>]

		<span style=color:#a6e22e>beforeCap</span> <span style=color:#f92672>:=</span> cap(<span style=color:#a6e22e>foo</span>)

		<span style=color:#a6e22e>foo</span> = append(<span style=color:#a6e22e>foo</span>, <span style=color:#a6e22e>i</span>)

		<span style=color:#a6e22e>firstNew</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>foo</span>[<span style=color:#ae81ff>0</span>]

		<span style=color:#75715e>// if the start of the underlying array changed
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>firstNew</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>first</span> {
			<span style=color:#a6e22e>afterCap</span>, <span style=color:#a6e22e>afterLen</span> <span style=color:#f92672>:=</span> cap(<span style=color:#a6e22e>foo</span>), len(<span style=color:#a6e22e>foo</span>)

			<span style=color:#a6e22e>capRatio</span> <span style=color:#f92672>:=</span> float64(<span style=color:#a6e22e>afterCap</span>) <span style=color:#f92672>/</span> float64(<span style=color:#a6e22e>beforeCap</span>)

			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%8v | %8v | %8v | %.2fx\n&#34;</span>, <span style=color:#a6e22e>afterLen</span>, <span style=color:#a6e22e>beforeCap</span>, <span style=color:#a6e22e>afterCap</span>, <span style=color:#a6e22e>capRatio</span>)
		}
	}
}
</code></pre></div><p>In the above code a slice of integers with 100 000 elements is created, by using only <code>append</code>.</p><p>The above code outputs:</p><pre><code>     len | prev cap |  new cap | ratio added cap
       2 |        1 |        2 | 2.00x
       3 |        2 |        4 | 2.00x
       5 |        4 |        8 | 2.00x
       9 |        8 |       16 | 2.00x
      17 |       16 |       32 | 2.00x
      33 |       32 |       64 | 2.00x
      65 |       64 |      128 | 2.00x
     129 |      128 |      256 | 2.00x
     257 |      256 |      512 | 2.00x
     513 |      512 |     1024 | 2.00x
    1025 |     1024 |     1280 | 1.25x
    1281 |     1280 |     1696 | 1.32x
    1697 |     1696 |     2304 | 1.36x
    2305 |     2304 |     3072 | 1.33x
    3073 |     3072 |     4096 | 1.33x
    4097 |     4096 |     5120 | 1.25x
    5121 |     5120 |     7168 | 1.40x
    7169 |     7168 |     9216 | 1.29x
    9217 |     9216 |    12288 | 1.33x
   12289 |    12288 |    15360 | 1.25x
   15361 |    15360 |    19456 | 1.27x
   19457 |    19456 |    24576 | 1.26x
   24577 |    24576 |    30720 | 1.25x
   30721 |    30720 |    38912 | 1.27x
   38913 |    38912 |    49152 | 1.26x
   49153 |    49152 |    61440 | 1.25x
   61441 |    61440 |    76800 | 1.25x
   76801 |    76800 |    96256 | 1.25x
   96257 |    96256 |   120832 | 1.26x
</code></pre><p>Interesting it looks like append is smart and doesn&rsquo;t only grow the slice to the currently needed capacity,
but doubles the capacity for smaller capacities (under 1024) and grows it by ~1.25x for larger capacities (over 1024),
to reduce the overhead of reallocating arrays.</p><p>In the runtime this is implemented as follows (<a href=https://github.com/golang/go/blob/c53315d6cf1b4bfea6ff356b4a1524778c683bb9/src/runtime/slice.go#L125>full implementation</a>):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>growslice</span>(<span style=color:#a6e22e>et</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>old</span> <span style=color:#a6e22e>slice</span>, <span style=color:#a6e22e>cap</span> <span style=color:#66d9ef>int</span>) <span style=color:#a6e22e>slice</span> {
<span style=color:#f92672>...</span>
    <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>cap</span>
    <span style=color:#a6e22e>doublecap</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>newcap</span>
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cap</span> &gt; <span style=color:#a6e22e>doublecap</span> {
        <span style=color:#a6e22e>newcap</span> = <span style=color:#a6e22e>cap</span>
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span> &lt; <span style=color:#ae81ff>1024</span> {
            <span style=color:#a6e22e>newcap</span> = <span style=color:#a6e22e>doublecap</span>
        } <span style=color:#66d9ef>else</span> {
            <span style=color:#75715e>// Check 0 &lt; newcap to detect overflow
</span><span style=color:#75715e></span>            <span style=color:#75715e>// and prevent an infinite loop.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> <span style=color:#ae81ff>0</span> &lt; <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>newcap</span> &lt; <span style=color:#a6e22e>cap</span> {
                <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>
            }
            <span style=color:#75715e>// Set newcap to the requested cap when
</span><span style=color:#75715e></span>            <span style=color:#75715e>// the newcap calculation overflowed.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
                <span style=color:#a6e22e>newcap</span> = <span style=color:#a6e22e>cap</span>
            }
        }
    }
<span style=color:#f92672>...</span>
}
</code></pre></div><h2 id=performance>Performance<a hidden class=anchor aria-hidden=true href=#performance>#</a></h2><p>I benchmarked what the performance impact of preallocating a slice with <code>make</code> vs auto growing via <code>append</code> is, the benchmark populates a slice with N integers them via a for loop.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>plainAppend</span>(<span style=color:#a6e22e>elms</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>foo</span> []<span style=color:#66d9ef>int</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>elms</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>foo</span> = append(<span style=color:#a6e22e>foo</span>, <span style=color:#a6e22e>i</span>)
	}
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>withMake</span>(<span style=color:#a6e22e>elms</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>foo</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>elms</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>elms</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>foo</span> = append(<span style=color:#a6e22e>foo</span>, <span style=color:#a6e22e>i</span>)
	}
}
</code></pre></div><p>Full Benchmark: <a href=https://gist.github.com/lu4p/4906f5d1b88f23a1f740bb8895f25e40>https://gist.github.com/lu4p/4906f5d1b88f23a1f740bb8895f25e40</a></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ go test -bench<span style=color:#f92672>=</span>. -count<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span> -benchtime<span style=color:#f92672>=</span>100x &gt; bench.out

<span style=color:#75715e># https://godoc.org/golang.org/x/perf/cmd/benchstat</span>
$ benchstat bench.out

name                  time/op
10/append-8            729ns ±62%
10/with_make-8         119ns ±84%
100/append-8          1.46µs ±84%
100/with_make-8        454ns ±99%
1k/append-8           5.28µs ±33%
1k/with_make-8        2.61µs ±54%
10k/append-8           111µs ±23%
10k/with_make-8       31.4µs ±11%
100k/append-8         1.16ms ± 8%
100k/with_make-8       248µs ±11%
1Million/append-8     8.57ms ± 3%
1Million/with_make-8  2.83ms ± 1%
</code></pre></div><p>So in a simple use case preallocating the slice with <code>make</code> seems to be about 2-4 times faster.
Although this is significant, in real-world scenarios it often doesn&rsquo;t really matter because appending is fast enough regardless.</p><p>If you don&rsquo;t know the number of elements a to which a slice will grow,
it often makes little sense to allocate memory with make beforehand.
Of course there are exceptions from this,
sometimes you know at least the order of magnitude to which a slice will grow,
then it can make sense to allocate a slice with a cap similar to the ballpark of expected elements.</p><p>Thanks to <a href=https://github.com/Hu1buerger>Hu1buerger</a>, for helping with the investigation.</p></div><footer class=post-footer><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Inner workings of allocating slices with go (golang) on twitter" href="https://twitter.com/intent/tweet/?text=Inner%20workings%20of%20allocating%20slices%20with%20go%20%28golang%29&url=https%3a%2f%2fblog.lu4p.xyz%2fposts%2fslices%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Inner workings of allocating slices with go (golang) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.lu4p.xyz%2fposts%2fslices%2f&title=Inner%20workings%20of%20allocating%20slices%20with%20go%20%28golang%29&summary=Inner%20workings%20of%20allocating%20slices%20with%20go%20%28golang%29&source=https%3a%2f%2fblog.lu4p.xyz%2fposts%2fslices%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Inner workings of allocating slices with go (golang) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.lu4p.xyz%2fposts%2fslices%2f&title=Inner%20workings%20of%20allocating%20slices%20with%20go%20%28golang%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Inner workings of allocating slices with go (golang) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.lu4p.xyz%2fposts%2fslices%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Inner workings of allocating slices with go (golang) on whatsapp" href="https://api.whatsapp.com/send?text=Inner%20workings%20of%20allocating%20slices%20with%20go%20%28golang%29%20-%20https%3a%2f%2fblog.lu4p.xyz%2fposts%2fslices%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Inner workings of allocating slices with go (golang) on telegram" href="https://telegram.me/share/url?text=Inner%20workings%20of%20allocating%20slices%20with%20go%20%28golang%29&url=https%3a%2f%2fblog.lu4p.xyz%2fposts%2fslices%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=lu4p/lu4p.github.io issue-term=pathname label="Blog Comment" theme=github-light crossorigin=anonymous id=comment-area async></script><script>if(document.body.classList.contains("dark")){var el=document.getElementById("comment-area")
el.setAttribute("theme","photon-dark")}else{var el=document.getElementById("comment-area")
el.setAttribute("theme","github-light")}</script></article></main><footer class=footer><span>&copy; 2020 <a href=https://blog.lu4p.xyz>lu4p's blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=https://blog.lu4p.xyz/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});if(id==="top"){history.replaceState(null,null," ");}else{history.replaceState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script async defer src=https://scripts.simpleanalyticscdn.com/latest.js></script><noscript><img src=https://queue.simpleanalyticscdn.com/noscript.gif alt></noscript></body></html>