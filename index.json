[{"content":"I use Echo in this post, but you could also use plain net/http, or any of the other awesome web frameworks for Go, see a list here.\nThe Go standard library provides a html/template package, for dynamically rendering HTML, it is built on top of text/template\nGo templates are normal HTML files, with \u0026ldquo;Actions\u0026rdquo; (data evaluations or control structures), these \u0026ldquo;Actions\u0026rdquo; are delimited via {{and}}.\nA template is executed via applying a data structure to it, the data structure is referenced as a dot . in the template.\nParsing Templates Templates can be defined as string literals in a Go file, but it\u0026rsquo;s easier for organizing your templates and utilizing HTML support in your editor, to write your templates as separate files.\nThis templates, _ := template.ParseGlob(\u0026quot;templates/*.html\u0026quot;), parses all .html files in the templates directory.\nWriting Templates This is an example template:\n{{ template \u0026#34;head\u0026#34; . }} {{ link \u0026#34;/foo\u0026#34; \u0026#34;Foo\u0026#34;}} \u0026lt;p class=\u0026#34;bg-gray-100\u0026#34;\u0026gt;{{.test}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{toString .slice }}\u0026lt;/p\u0026gt; {{ template \u0026#34;foot\u0026#34; }} But what does this do exactly?\n{{ template \u0026quot;head\u0026quot; . }} embeds the head template from elsewhere and passes all template data to it (indicated by the dot).\n{{ link \u0026quot;/foo\u0026quot; \u0026quot;Foo\u0026quot;}} calls the function link with the parameters \u0026quot;/foo\u0026quot; and \u0026quot;Foo\u0026quot;, in plain Go this would be link(\u0026quot;/foo\u0026quot;, \u0026quot;Foo\u0026quot;).\n{{.test}} outputs the value of .test.\n{{ toString .slice }} calls the function toString with the parameter .slice.\n{{ template \u0026quot;foot\u0026quot; }} embeds the foot template from elsewhere, no data is passed (notice the missing dot).\nPassing data to a template (rendering) func root(c echo.Context) error { return c.Render(200, \u0026#34;index.html\u0026#34;, map[string]interface{}{ \u0026#34;title\u0026#34;: \u0026#34;Root\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;Hello, world!\u0026#34;, \u0026#34;slice\u0026#34;: []int{1, 2, 3}, }) } A template is executed via supplying data for \u0026ldquo;dot\u0026rdquo; (.). In Echo this is done with c.Render inside a handler function.\nYou pass a HTTP status code (200), the name of the template to execute (index.html), and the data (in this case a map literal).\nTo access the data from the template you can use \u0026ldquo;dot\u0026rdquo;, an element of the map can be accessed via .key, for structs it\u0026rsquo;s similarly .field, methods of a data type can be called via .Method.\nRegistering Functions It is nice to execute functions right in the template, for control flow e.g. \u0026ldquo;Is a user logged in?\u0026rdquo;, or to render something.\nA function can be added to a template as follows:\nt := template.New(\u0026#34;new-template\u0026#34;) t.Funcs(template.FuncMap{ \u0026#34;email\u0026#34;: func() string { return \u0026#34;example@example.com\u0026#34; }, \u0026#34;anotherFunc\u0026#34;: anotherFunc, }) In your template you can then call the email function to show the email of the currently logged in user.\n\u0026lt;p\u0026gt;Your email address: {{ email }}\u0026lt;/p\u0026gt; Defining templates You can define reusable blocks of HTML via wrapping the code in a \u0026ldquo;define\u0026rdquo; block, see the following example:\n{{ define \u0026#34;p\u0026#34;}} \u0026lt;p\u0026gt;{{.}}\u0026lt;/p\u0026gt; {{ end }} This can then be used in another template/ file via:\n{{ template \u0026#34;p\u0026#34; \u0026#34;Some content\u0026#34;}} And will output:\n\u0026lt;p\u0026gt;Some content\u0026lt;/p\u0026gt; A more real world use case would be the following, which defines a \u0026ldquo;head\u0026rdquo; and a \u0026ldquo;foot\u0026rdquo; template:\n# templates/base.html {{ define \u0026#34;head\u0026#34; }} \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;{{.title}}\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/dist/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;/dist/main.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container mx-auto\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{.title}}\u0026lt;/h1\u0026gt; {{ end }} {{ define \u0026#34;foot\u0026#34; }} \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; {{ end }} These templates were already used in the example template from the beginning:\n# templates/index.html {{ template \u0026#34;head\u0026#34; . }} {{ link \u0026#34;/foo\u0026#34; \u0026#34;Foo\u0026#34;}} \u0026lt;p class=\u0026#34;bg-gray-100\u0026#34;\u0026gt;{{.test}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{toString .slice }}\u0026lt;/p\u0026gt; {{ template \u0026#34;foot\u0026#34; }} There is more Go templates also support additional functionality not covered in this post, notably:\n if/ else blocks for conditional rendering range for looping over a slice, map, array or channel with only rendering if a value exists  See https://pkg.go.dev/text/template, for more information.\nSample Project I wrote a quick sample project which also includes additional functionality, it can be found here.\nThe sample project also uses:\n Turbo, part of Hotwire a new approach from Basecamp for writing modern web applications without much JavaScript. I will maybe do a separate post about Turbo in the Future. tailwindcss, makes HTML look nice. webpack, for packing JS and CSS into single files, with minimization enabled, setup to extract CSS to a separate file. Air, for hot reloading Go code and templates on change.  ","permalink":"https://blog.lu4p.xyz/posts/golang-template-turbo/","summary":"I use Echo in this post, but you could also use plain net/http, or any of the other awesome web frameworks for Go, see a list here.\nThe Go standard library provides a html/template package, for dynamically rendering HTML, it is built on top of text/template\nGo templates are normal HTML files, with \u0026ldquo;Actions\u0026rdquo; (data evaluations or control structures), these \u0026ldquo;Actions\u0026rdquo; are delimited via {{and}}.\nA template is executed via applying a data structure to it, the data structure is referenced as a dot .","title":"Understanding HTML templates in Go (golang)"},{"content":"I wasn\u0026rsquo;t sure what the performance impact of preallocating a slice with make vs. just letting the slice grow via append is, so I investigated a little.\nArrays In order to understand what a slice is one needs to first understand how arrays work in go.\nAn array\u0026rsquo;s type definition specifies a length and an element type. For example, the type [3]int represents an array of three integers.\nAn array\u0026rsquo;s size is fixed, its length is part of the type, so [2]int and [3]int are incompatible, e.g. a variable of type [2]int cannot be assigned to a variable of type [3]int.\na := [2]int{1, 2} var b [3]int b = a // Output: cannot use a (type [2]int) as type [3]int in assignment Arrays are initialized right away, the zero value of an array is an array whose elements have their zero value.\nvar b [2]int fmt.Println(b[1]) // Output: 0 In-memory a variable of type [3]int is just 3 integers laid out sequentially.\nAn array is a value, an [3]int variable are just 3 integers, being passed around.\nSlices First of all what is a slice exactly, a slice can be thought of a struct with the following values:\ntype slice struct { len int // the length of the slice \tcap int // the capacity of the slice i.e. the max possible len without allocating new memory \tptr unsafe.Pointer // pointer to the first Element of the underlying array } append append needs to allocate a new underlying array, if the elements to append exceed the capacity of the underlying array, in this case a new bigger array is allocated, all elements copied from the old to the new array, and the new elements are copied after the last element of the copied slice.\n cap is set to the length of the newly allocated array, len is to the index of the last element added via append (+ 1) ptr is set to point to the underlying array  For performance it\u0026rsquo;s important how often the values are copied around in memory.\nThis is what I came up with, to determine how often the slice is reallocated and copied, I also print some useful information about the allocated capacity of the slice.\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { elmCount := 100_000 fmt.Printf(\u0026#34;%8v | %8v | %8v | %v\\n\u0026#34;, \u0026#34;len\u0026#34;, \u0026#34;prev cap\u0026#34;, \u0026#34;new cap\u0026#34;, \u0026#34;ratio added cap\u0026#34;) var foo []int for i := 0; i \u0026lt; elmCount; i++ { if i == 0 { foo = append(foo, i) continue } first := \u0026amp;foo[0] beforeCap := cap(foo) foo = append(foo, i) firstNew := \u0026amp;foo[0] // if the start of the underlying array changed \tif firstNew != first { afterCap, afterLen := cap(foo), len(foo) capRatio := float64(afterCap) / float64(beforeCap) fmt.Printf(\u0026#34;%8v | %8v | %8v | %.2fx\\n\u0026#34;, afterLen, beforeCap, afterCap, capRatio) } } } In the above code a slice of integers with 100 000 elements is created, by using only append.\nThe above code outputs:\n len | prev cap | new cap | ratio added cap 2 | 1 | 2 | 2.00x 3 | 2 | 4 | 2.00x 5 | 4 | 8 | 2.00x 9 | 8 | 16 | 2.00x 17 | 16 | 32 | 2.00x 33 | 32 | 64 | 2.00x 65 | 64 | 128 | 2.00x 129 | 128 | 256 | 2.00x 257 | 256 | 512 | 2.00x 513 | 512 | 1024 | 2.00x 1025 | 1024 | 1280 | 1.25x 1281 | 1280 | 1696 | 1.32x 1697 | 1696 | 2304 | 1.36x 2305 | 2304 | 3072 | 1.33x 3073 | 3072 | 4096 | 1.33x 4097 | 4096 | 5120 | 1.25x 5121 | 5120 | 7168 | 1.40x 7169 | 7168 | 9216 | 1.29x 9217 | 9216 | 12288 | 1.33x 12289 | 12288 | 15360 | 1.25x 15361 | 15360 | 19456 | 1.27x 19457 | 19456 | 24576 | 1.26x 24577 | 24576 | 30720 | 1.25x 30721 | 30720 | 38912 | 1.27x 38913 | 38912 | 49152 | 1.26x 49153 | 49152 | 61440 | 1.25x 61441 | 61440 | 76800 | 1.25x 76801 | 76800 | 96256 | 1.25x 96257 | 96256 | 120832 | 1.26x Interesting it looks like append is smart and doesn\u0026rsquo;t only grow the slice to the currently needed capacity, but doubles the capacity for smaller capacities (under 1024) and grows it by ~1.25x for larger capacities (over 1024), to reduce the overhead of reallocating arrays.\nIn the runtime this is implemented as follows (full implementation):\nfunc growslice(et *_type, old slice, cap int) slice { ... newcap := old.cap doublecap := newcap + newcap if cap \u0026gt; doublecap { newcap = cap } else { if old.len \u0026lt; 1024 { newcap = doublecap } else { // Check 0 \u0026lt; newcap to detect overflow  // and prevent an infinite loop.  for 0 \u0026lt; newcap \u0026amp;\u0026amp; newcap \u0026lt; cap { newcap += newcap / 4 } // Set newcap to the requested cap when  // the newcap calculation overflowed.  if newcap \u0026lt;= 0 { newcap = cap } } } ... } Performance I benchmarked what the performance impact of preallocating a slice with make vs auto growing via append is, the benchmark populates a slice with N integers them via a for loop.\nfunc plainAppend(elms int) { var foo []int for i := 0; i \u0026lt; elms; i++ { foo = append(foo, i) } } func withMake(elms int) { foo := make([]int, 0, elms) for i := 0; i \u0026lt; elms; i++ { foo = append(foo, i) } } Full Benchmark: https://gist.github.com/lu4p/4906f5d1b88f23a1f740bb8895f25e40\n$ go test -bench=. -count=10 -benchtime=100x \u0026gt; bench.out # https://godoc.org/golang.org/x/perf/cmd/benchstat $ benchstat bench.out name time/op 10/append-8 729ns ±62% 10/with_make-8 119ns ±84% 100/append-8 1.46µs ±84% 100/with_make-8 454ns ±99% 1k/append-8 5.28µs ±33% 1k/with_make-8 2.61µs ±54% 10k/append-8 111µs ±23% 10k/with_make-8 31.4µs ±11% 100k/append-8 1.16ms ± 8% 100k/with_make-8 248µs ±11% 1Million/append-8 8.57ms ± 3% 1Million/with_make-8 2.83ms ± 1% So in a simple use case preallocating the slice with make seems to be about 2-4 times faster. Although this is significant, in real-world scenarios it often doesn\u0026rsquo;t really matter because appending is fast enough regardless.\nIf you don\u0026rsquo;t know the number of elements a to which a slice will grow, it often makes little sense to allocate memory with make beforehand. Of course there are exceptions from this, sometimes you know at least the order of magnitude to which a slice will grow, then it can make sense to allocate a slice with a cap similar to the ballpark of expected elements.\nThanks to Hu1buerger, for helping with the investigation.\n","permalink":"https://blog.lu4p.xyz/posts/slices/","summary":"I wasn\u0026rsquo;t sure what the performance impact of preallocating a slice with make vs. just letting the slice grow via append is, so I investigated a little.\nArrays In order to understand what a slice is one needs to first understand how arrays work in go.\nAn array\u0026rsquo;s type definition specifies a length and an element type. For example, the type [3]int represents an array of three integers.\nAn array\u0026rsquo;s size is fixed, its length is part of the type, so [2]int and [3]int are incompatible, e.","title":"Inner workings of allocating slices with Go (golang)"},{"content":"","permalink":"https://blog.lu4p.xyz/archive/","summary":"archive","title":"Archive"},{"content":"","permalink":"https://blog.lu4p.xyz/search/","summary":"search","title":"Search"}]